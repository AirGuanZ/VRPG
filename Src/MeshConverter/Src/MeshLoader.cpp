#include <VRPG/MeshConverter/MeshLoader.h>

VRPG_MESH_CONVERTER_BEGIN

namespace
{
    std::string GenerateBoneName()
    {
        static int nextAutoNameIndex = 0;
        return "BoneWithAutoGeneratedName_" + std::to_string(nextAutoNameIndex++);
    }

    /**
     * 提取node处的骨骼，将它加入bones，然后递归地提取node的孩子结点
     */
    void LoadStaticSkeletonAux(
        const aiNode *node, std::vector<Mesh::StaticSkeleton::Bone> &bones, int directParentIndex,
        std::multimap<int, int> &boneIndexToMeshIndex)
    {
        assert(node);

        std::string newBoneName = node->mName.C_Str();
        if(newBoneName.empty())
        {
            newBoneName = GenerateBoneName();
        }

        auto &T = node->mTransformation;

        Mesh::StaticSkeleton::Bone newBone;
        newBone.name   = newBoneName;
        newBone.parent = directParentIndex;
        newBone.staticTransform = Mat4(T[0][0], T[0][1], T[0][2], T[0][3],
                                       T[1][0], T[1][1], T[1][2], T[1][3],
                                       T[2][0], T[2][1], T[2][2], T[2][3],
                                       T[3][0], T[3][1], T[3][2], T[3][3])
                                  .transpose();

        int newBoneIndex = static_cast<int>(bones.size());

        spdlog::info("find new bone");
        spdlog::info("  bone name   = {}", newBone.name);
        spdlog::info("  bone index  = {}", newBoneIndex);
        spdlog::info("  bone parent = {}", directParentIndex);

        bones.push_back(std::move(newBone));

        for(unsigned int i = 0; i < node->mNumMeshes; ++i)
        {
            boneIndexToMeshIndex.insert(std::make_pair(newBoneIndex, node->mMeshes[i]));
        }

        for(unsigned int i = 0; i < node->mNumChildren; ++i)
        {
            LoadStaticSkeletonAux(node->mChildren[i], bones, newBoneIndex, boneIndexToMeshIndex);
        }
    }

    /**
     * 提取单个骨骼动画
     */
    Mesh::BoneAnimation LoadBoneAnimation(const aiNodeAnim *node)
    {
        if(node->mNumPositionKeys != node->mNumRotationKeys ||
           node->mNumRotationKeys != node->mNumScalingKeys)
        {
            // 平移、旋转和缩放的关键帧数量应该一致

            throw VRPGMeshConverterException(
                "invalid aiNodeAnim node: inconsistent numbers of pos/rot/scl keyframes");
        }

        std::vector<Mesh::BoneTransformKeyFrame> keyframes;
        keyframes.reserve(node->mNumPositionKeys);

        for(unsigned int i = 0; i < node->mNumPositionKeys; ++i)
        {
            auto &kPos = node->mPositionKeys[i];
            auto &kRot = node->mRotationKeys[i];
            auto &kScl = node->mScalingKeys[i];

            constexpr double EPS = 1e-5;
            if(std::abs(kPos.mTime - kRot.mTime) > EPS ||
               std::abs(kRot.mTime - kScl.mTime) > EPS)
            {
                // 平移、旋转和缩放的关键帧应该在时间上逐帧对应

                throw VRPGMeshConverterException(
                    "invalid aiNodeAni node: inconsistent time points of pos/rot/scl keyframes");
            }

            Mesh::BoneTransformKeyFrame keyframe;
            keyframe.timePoint = static_cast<float>(kPos.mTime);
            keyframe.translate = Vec3(kPos.mValue.x, kPos.mValue.y, kPos.mValue.z);
            keyframe.rotate    = Quaternion(kRot.mValue.w, kRot.mValue.x, kRot.mValue.y, kRot.mValue.z);
            keyframe.scale     = Vec3(kScl.mValue.x, kScl.mValue.y, kScl.mValue.z);

            keyframes.push_back(keyframe);
        }

        keyframes.shrink_to_fit();
        return Mesh::BoneAnimation(std::move(keyframes));
    }

    Mesh::MeshComponent LoadMeshComponent(const aiMesh *mesh)
    {
        // 填充顶点数组

        if(!mesh->mNormals)
        {
            throw VRPGMeshConverterException("normal array is NULL");
        }

        std::vector<Mesh::MeshVertex> vertices;
        vertices.reserve(mesh->mNumVertices);
        if(!mesh->mTextureCoords[0])
        {
            for(unsigned vtxIdx = 0; vtxIdx < mesh->mNumVertices; ++vtxIdx)
            {
                auto &pos = mesh->mVertices[vtxIdx];
                auto &nor = mesh->mNormals[vtxIdx];
                vertices.push_back({
                    { pos.x, pos.y, pos.z },
                    { nor.x, nor.y, nor.z },
                    { 0, 0 }
                });
            }
        }
        else
        {
            for(unsigned vtxIdx = 0; vtxIdx < mesh->mNumVertices; ++vtxIdx)
            {
                auto &pos = mesh->mVertices[vtxIdx];
                auto &nor = mesh->mNormals[vtxIdx];
                auto &uv  = mesh->mTextureCoords[0][vtxIdx];
                vertices.push_back({
                    { pos.x, pos.y, pos.z },
                    { nor.x, nor.y, nor.z },
                    { uv.x, uv.y }
                });
            }
        }

        // 遍历所有三角面片，填充index数组

        assert(mesh->mPrimitiveTypes == aiPrimitiveType_TRIANGLE);

        std::vector<uint32_t> indices;
        indices.reserve(3 * mesh->mNumFaces);
        for(unsigned faceIdx = 0; faceIdx < mesh->mNumFaces; ++faceIdx)
        {
            const aiFace &face = mesh->mFaces[faceIdx];
            assert(face.mNumIndices == 3);

            indices.push_back(face.mIndices[0]);
            indices.push_back(face.mIndices[1]);
            indices.push_back(face.mIndices[2]);
        }

        return { std::move(vertices), std::move(indices) };
    }
}

/**
 * @brief 从aiScene中提取静态骨架结构
 */
Mesh::StaticSkeleton LoadStaticSkeleton(const aiScene *scene, std::multimap<int, int> &boneIndexToMeshIndex)
{
    boneIndexToMeshIndex.clear();
    std::vector<Mesh::StaticSkeleton::Bone> bones;
    LoadStaticSkeletonAux(scene->mRootNode, bones, -1, boneIndexToMeshIndex);
    bones.shrink_to_fit();
    return Mesh::StaticSkeleton(std::move(bones));
}

/**
 * @brief 从aiScene中提取指定骨架上的所有骨骼动画
 */
std::vector<std::pair<std::string, Mesh::SkeletonAnimation>> LoadSkeletonAnimation(
    const aiScene *scene, const Mesh::StaticSkeleton &skeleton)
{
    std::vector<std::pair<std::string, Mesh::SkeletonAnimation>> animations;
    animations.reserve(scene->mNumAnimations);

    spdlog::info("animation count: {}", scene->mNumAnimations);

    // 遍历所有动画
    for(unsigned int aniIndex = 0; aniIndex < scene->mNumAnimations; ++aniIndex)
    {
        const aiAnimation *animation = scene->mAnimations[aniIndex];

        std::string animationName = animation->mName.C_Str();
        spdlog::info("load animation {}", animationName.c_str());

        std::vector<Mesh::BoneAnimation> boneAnimations(skeleton.GetBoneCount());

        // 遍历该动画中涉及到的所有骨骼
        for(unsigned int chIdx = 0; chIdx < animation->mNumChannels; ++chIdx)
        {
            const aiNodeAnim *channel = animation->mChannels[chIdx];

            std::string boneName = channel->mNodeName.C_Str();
            int boneIndex = skeleton.BoneNameToIndex(boneName);
            if(boneIndex < 0)
            {
                // 忽略给定的骨架上找不到的骨骼
                continue;
            }

            spdlog::info("bone name = {}", boneName);
            boneAnimations[boneIndex] = LoadBoneAnimation(channel);
        }
        Mesh::SkeletonAnimation skeletonAnimation(std::move(boneAnimations));
        animations.emplace_back(animationName, std::move(skeletonAnimation));
    }

    return animations;
}

Mesh::Mesh LoadMesh(const aiScene *scene)
{
    assert(scene);

    spdlog::info("load static skeleton...");

    std::multimap<int, int> boneIndexToMeshIndex;
    auto staticSkeleton = LoadStaticSkeleton(scene, boneIndexToMeshIndex);

    std::map<int, int> meshIndexToBoneIndex;
    for(auto &p : boneIndexToMeshIndex)
    {
        meshIndexToBoneIndex.insert(std::make_pair(p.second, p.first));
    }

    std::vector<Mat4> staticBoneTransforms(staticSkeleton.GetBoneCount());
    staticSkeleton.ComputeStaticTransformMatrix(staticBoneTransforms.data());

    spdlog::info("load skeleton animations...");

    auto skeletonAnimations = LoadSkeletonAnimation(scene, staticSkeleton);

    std::map<std::string, Mesh::SkeletonAnimation, std::less<>> skeletonAnimationMap;
    for(auto &ani : skeletonAnimations)
    {
        skeletonAnimationMap.insert(std::move(ani));
    }

    spdlog::info("load mesh components...");

    std::vector<Mesh::Mesh::MeshComponentBinding> meshComponentBindings;
    meshComponentBindings.reserve(scene->mNumMeshes);

    spdlog::info("mesh count: {}", scene->mNumMeshes);

    for(unsigned int meshIdx = 0; meshIdx < scene->mNumMeshes; ++meshIdx)
    {
        const aiMesh *mesh = scene->mMeshes[meshIdx];

        AGZ_HIERARCHY_TRY

        Mesh::MeshComponent meshComponent = LoadMeshComponent(mesh);
        std::string meshName = mesh->mName.C_Str();

        spdlog::info("find new mesh");
        spdlog::info("  mesh name = {} ", meshName.c_str());

        spdlog::info("  mesh bone count = {}", mesh->mNumBones);

        int boneIndex = -1;
        Mat4 bindingTransform = Mat4::identity();

        for(unsigned j = 0; j < mesh->mNumBones; ++j)
        {
            auto bone = mesh->mBones[j];
            spdlog::info("  mesh bone name = {}", bone->mName.C_Str());

            if(bone->mNumWeights > 0 && bone->mWeights[0].mWeight > 0.9f)
            {
                boneIndex = staticSkeleton.BoneNameToIndex(bone->mName.C_Str());
                spdlog::info("  select bone name = {}", bone->mName.C_Str());
                if(boneIndex >= 0)
                {
                    auto &T = bone->mOffsetMatrix;
                    bindingTransform = Mat4(T[0][0], T[0][1], T[0][2], T[0][3],
                                            T[1][0], T[1][1], T[1][2], T[1][3], 
                                            T[2][0], T[2][1], T[2][2], T[2][3], 
                                            T[3][0], T[3][1], T[3][2], T[3][3])
                                       .transpose();
                }
                break;
            }
        }

        int staticBoneIndex = meshIndexToBoneIndex[static_cast<int>(meshIdx)];
        
        meshComponentBindings.push_back({
            std::move(meshName), std::move(meshComponent),
            boneIndex, staticBoneTransforms[staticBoneIndex], bindingTransform
        });

        AGZ_HIERARCHY_WRAP("in loading mesh: " + std::string(mesh->mName.C_Str()))
    }

    return {
        std::move(meshComponentBindings),
        std::move(skeletonAnimationMap),
        std::move(staticSkeleton)
    };
}

VRPG_MESH_CONVERTER_END
